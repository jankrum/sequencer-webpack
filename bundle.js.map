{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://web-sequencer-webpack/./node_modules/callbag-map/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-observe/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-pipe/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-worker/index.js","webpack://web-sequencer-webpack/webpack/bootstrap","webpack://web-sequencer-webpack/webpack/runtime/compat get default export","webpack://web-sequencer-webpack/webpack/runtime/define property getters","webpack://web-sequencer-webpack/webpack/runtime/get javascript chunk filename","webpack://web-sequencer-webpack/webpack/runtime/global","webpack://web-sequencer-webpack/webpack/runtime/hasOwnProperty shorthand","webpack://web-sequencer-webpack/webpack/runtime/publicPath","webpack://web-sequencer-webpack/webpack/runtime/jsonp chunk loading","webpack://web-sequencer-webpack/./src/modules/sequencer.js","webpack://web-sequencer-webpack/./node_modules/callbag-merge/readme.js","webpack://web-sequencer-webpack/./src/modules/transporter.js","webpack://web-sequencer-webpack/./node_modules/callbag-from-event/index.js","webpack://web-sequencer-webpack/./src/index.js"],"sourcesContent":["/**\n * callbag-map\n * -----------\n *\n * Callbag operator that applies a transformation on data passing through it.\n * Works on either pullable or listenable sources.\n *\n * `npm install callbag-map`\n *\n * Example:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const iterate = require('callbag-iterate');\n *     const map = require('callbag-map');\n *\n *     const source = map(x => x * 0.1)(fromIter([10,20,30,40]));\n *\n *     iterate(x => console.log(x))(source); // 1\n *                                           // 2\n *                                           // 3\n *                                           // 4\n */\n\nconst map = f => source => (start, sink) => {\n  if (start !== 0) return;\n  source(0, (t, d) => {\n    sink(t, t === 1 ? f(d) : d)\n  });\n};\n\nmodule.exports = map;\n","const observe = operation => source => {\n  source(0, (t, d) => {\n    if (t === 1) operation(d);\n  });\n}\n\nmodule.exports = observe;\n","/**\n * callbag-pipe\n * ------------\n *\n * Utility function for plugging callbags together in chain. This utility\n * actually doesn't rely on Callbag specifics, and is really similar to\n * Ramda's `pipe` or lodash's `flow`.\n * \n * Implementation of `callbag-pipe` using `R.pipe` could look like this:\n *\n * const pipe = (source, ...cbs) => R.pipe(...cbs)(source)\n * \n * This exists to play nicely with the ecosystem,\n * and to facilitate the import of the function.\n *\n * `npm install callbag-pipe`\n *\n * Example:\n *\n * Create a source with `pipe`, then pass it to a `forEach`:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     const source = pipe(\n *       combine(interval(100), interval(350)),\n *       map(([x, y]) => `X${x},Y${y}`),\n *       take(10)\n *     );\n *\n *     forEach(x => console.log(x))(source); // X2,Y0\n *                                           // X3,Y0\n *                                           // X4,Y0\n *                                           // X5,Y0\n *                                           // X6,Y0\n *                                           // X6,Y1\n *                                           // X7,Y1\n *                                           // X8,Y1\n *                                           // X9,Y1\n *                                           // X9,Y2\n *\n *\n * Or use `pipe` to go all the way from source to sink:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       map(([x, y]) => `X${x},Y${y}`),\n *       take(10),\n *       forEach(x => console.log(x))\n *     );\n *     // X2,Y0\n *     // X3,Y0\n *     // X4,Y0\n *     // X5,Y0\n *     // X6,Y0\n *     // X6,Y1\n *     // X7,Y1\n *     // X8,Y1\n *     // X9,Y1\n *     // X9,Y2\n *\n *\n * Nesting\n * -------\n *\n * To use pipe inside another pipe, you need to give the inner pipe an\n * argument, e.g. `s => pipe(s, ...`:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       s => pipe(s,\n *         map(([x, y]) => `X${x},Y${y}`),\n *         take(10)\n *       ),\n *       forEach(x => console.log(x))\n *     );\n *\n *\n * This means you can use pipe to create a new operator:\n *\n *     const mapThenTake = (f, amount) =>\n *       s => pipe(s, map(f), take(amount));\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       mapThenTake(([x, y]) => `X${x},Y${y}`, 10),\n *       forEach(x => console.log(x))\n *     );\n *\n */\n\nfunction pipe(...cbs) {\n  let res = cbs[0];\n  for (let i = 1, n = cbs.length; i < n; i++) res = cbs[i](res);\n  return res;\n}\n\nmodule.exports = pipe;\n","const toWorker = fileOrWorker =>\n  typeof fileOrWorker === 'string' \n    ? new Worker(fileOrWorker)\n    : fileOrWorker\n\nconst workerSource = fileOrWorker => {\n  const w = toWorker(fileOrWorker)\n  return (start, sink) => {\n    if (start !== 0) return\n    const onMsg = ev => {\n      const {type, data} = JSON.parse(ev.data)\n      if (type !== 0) sink(type, data)\n    }\n    if (w.addEventListener) w.addEventListener('message', onMsg)\n    else w.onmessage = onMsg\n    sink(0, (t, d) => {\n      w.postMessage(JSON.stringify({type: t, data: d}))\n      if (t === 2) (w.close || w.terminate).call(w)\n    })\n  }\n}\n\nconst workerSink = fileOrWorker => source => {\n  const w = toWorker(fileOrWorker)\n  let talkback;\n  const onMsg = ev => {\n    const {type, data} = JSON.parse(ev.data)\n    talkback(type, data)\n  }\n  source(0, (t, d) => {\n    if (t === 0) {\n      talkback = d\n      if (w.addEventListener) w.addEventListener('message', onMsg)\n      else w.onmessage = onMsg\n      w.postMessage(JSON.stringify({type: 0}))\n    }\n    if (t === 1) w.postMessage(JSON.stringify({type: t, data: d}))\n    if (t === 2) {\n      w.postMessage(JSON.stringify({type: t, data: d}))\n      const close = w.close || w.terminate\n      close.call(w);\n    }\n  })\n}\n\nmodule.exports = {workerSource, workerSink};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t792: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","import observe from 'callbag-observe'\n\nexport default function sequencer(transporter$, worker$) {\n    worker$(0, (type, data) => {\n        if (type === 0) {\n            const talkback = data\n            observe(d => {\n                console.log('from transporter', d)\n                talkback(1, null)\n            })(transporter$)\n            talkback(1, null)\n            // setInterval(() => talkback(1, null), 2000)\n        }\n        if (type === 1) console.log('from worker', data)\n    })\n}","/**\n * callbag-merge\n * -------------\n *\n * Callbag factory that merges data from multiple callbag sources. Works well\n * with listenable sources, and while it may work for some pullable sources,\n * it is only designed for listenable sources.\n *\n * `npm install callbag-merge`\n *\n * Example:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const merge = require('callbag-merge');\n *\n *     const source = merge(interval(100), interval(350));\n *\n *     forEach(x => console.log(x))(source); // 0\n *                                           // 1\n *                                           // 2\n *                                           // 0\n *                                           // 3\n *                                           // 4\n *                                           // 5\n *                                           // ...\n */\n\nfunction merge(...sources) {\n  return (start, sink) => {\n    if (start !== 0) return;\n    const n = sources.length;\n    const sourceTalkbacks = new Array(n);\n    let startCount = 0;\n    let endCount = 0;\n    let ended = false;\n    const talkback = (t, d) => {\n      if (t === 2) ended = true;\n      for (let i = 0; i < n; i++) sourceTalkbacks[i] && sourceTalkbacks[i](t, d);\n    };\n    for (let i = 0; i < n; i++) {\n      if (ended) return;\n      sources[i](0, (t, d) => {\n        if (t === 0) {\n          sourceTalkbacks[i] = d;\n          if (++startCount === 1) sink(0, talkback);\n        } else if (t === 2 && d) {\n          ended = true;\n          for (let j = 0; j < n; j++) {\n            if (j !== i) sourceTalkbacks[j] && sourceTalkbacks[j](2);\n          }\n          sink(2, d);\n        } else if (t === 2) {\n          sourceTalkbacks[i] = void 0;\n          if (++endCount === n) sink(2);\n        } else sink(t, d);\n      });\n    }\n  };\n}\n\nexport default merge;\n","import fromEvent from 'callbag-from-event'\nimport map from 'callbag-map'\nimport pipe from 'callbag-pipe'\nimport merge from 'callbag-merge'\n\nconst buttonNames = ['play', 'pause', 'stop']\n\nfunction makeEmitterFromButton(name) {\n    const button = document.querySelector(`#${name}`)\n    const emitter$ = fromEvent(button, 'click')\n    const mapToName = map(() => name)\n\n    return pipe(emitter$, mapToName)\n}\n\nconst buttonEmitters = buttonNames.map(makeEmitterFromButton)\n\nconst transporter$ = merge(...buttonEmitters)\n\nexport default transporter$","const fromEvent = (node, name, options) => (start, sink) => {\n  if (start !== 0) return;\n  let disposed = false;\n  const handler = ev => {\n    sink(1, ev)\n  };\n\n  sink(0, t => {\n    if (t !== 2) {\n      return;\n    }\n    disposed = true;\n    if (node.removeEventListener) node.removeEventListener(name, handler, options);\n    else if (node.removeListener) node.removeListener(name, handler);\n    else throw new Error('cannot remove listener from node. No method found.');\n  });\n\n  if (disposed) {\n    return;\n  }\n\n  if (node.addEventListener) node.addEventListener(name, handler, options);\n  else if (node.addListener) node.addListener(name, handler);\n  else throw new Error('cannot add listener to node. No method found.');\n};\n\nexport default fromEvent;\n","import sequencer from './modules/sequencer.js'\nimport { workerSource } from 'callbag-worker'\n\nimport transporter$ from './modules/transporter'\n\nconst worker$ = workerSource(new Worker(new URL('./worker.js', import.meta.url)))\n\nsequencer(transporter$, worker$)"],"names":["module","exports","f","source","start","sink","t","d","operation","cbs","res","i","n","length","toWorker","fileOrWorker","Worker","workerSource","w","onMsg","ev","type","data","JSON","parse","addEventListener","onmessage","postMessage","stringify","close","terminate","call","workerSink","talkback","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","m","getter","__esModule","a","definition","key","o","Object","defineProperty","enumerable","get","u","chunkId","g","globalThis","this","Function","e","window","obj","prop","prototype","hasOwnProperty","scriptUrl","importScripts","location","document","currentScript","tagName","toUpperCase","src","scripts","getElementsByTagName","test","Error","replace","p","b","baseURI","self","href","transporter$","sources","sourceTalkbacks","Array","startCount","endCount","ended","j","map","name","emitter$","node","options","disposed","handler","removeEventListener","removeListener","addListener","querySelector","mapToName","URL","worker$","console","log"],"sourceRoot":""}