{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://web-sequencer-webpack/./node_modules/callbag-basics/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-combine/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-concat/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-filter/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-flatten/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-for-each/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-from-event/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-from-iter/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-from-obs/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-from-promise/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-interval/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-map/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-merge/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-pipe/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-scan/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-share/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-skip/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-take/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-worker/index.js","webpack://web-sequencer-webpack/./node_modules/symbol-observable/es/index.js","webpack://web-sequencer-webpack/./node_modules/symbol-observable/es/ponyfill.js","webpack://web-sequencer-webpack/webpack/bootstrap","webpack://web-sequencer-webpack/webpack/runtime/compat get default export","webpack://web-sequencer-webpack/webpack/runtime/define property getters","webpack://web-sequencer-webpack/webpack/runtime/get javascript chunk filename","webpack://web-sequencer-webpack/webpack/runtime/global","webpack://web-sequencer-webpack/webpack/runtime/harmony module decorator","webpack://web-sequencer-webpack/webpack/runtime/hasOwnProperty shorthand","webpack://web-sequencer-webpack/webpack/runtime/make namespace object","webpack://web-sequencer-webpack/webpack/runtime/publicPath","webpack://web-sequencer-webpack/webpack/runtime/jsonp chunk loading","webpack://web-sequencer-webpack/./src/index.js"],"sourcesContent":["module.exports = {\n  forEach: require('callbag-for-each'),\n  fromObs: require('callbag-from-obs'),\n  fromIter: require('callbag-from-iter'),\n  fromEvent: require('callbag-from-event'),\n  fromPromise: require('callbag-from-promise'),\n  interval: require('callbag-interval'),\n  map: require('callbag-map'),\n  scan: require('callbag-scan'),\n  flatten: require('callbag-flatten'),\n  take: require('callbag-take'),\n  skip: require('callbag-skip'),\n  filter: require('callbag-filter'),\n  merge: require('callbag-merge'),\n  concat: require('callbag-concat'),\n  combine: require('callbag-combine'),\n  share: require('callbag-share'),\n  pipe: require('callbag-pipe')\n};\n\n","/**\n * callbag-combine\n * ---------------\n *\n * Callbag factory that combines the latest data points from multiple (2 or\n * more) callbag sources. It delivers those latest values as an array. Works\n * with both pullable and listenable sources.\n *\n * `npm install callbag-combine`\n *\n * Example:\n *\n *     const interval = require('callbag-interval');\n *     const observe = require('callbag-observe');\n *     const combine = require('callbag-combine');\n *\n *     const source = combine(interval(100), interval(350));\n *\n *     observe(x => console.log(x))(source); // [2,0]\n *                                           // [3,0]\n *                                           // [4,0]\n *                                           // [5,0]\n *                                           // [6,0]\n *                                           // [6,1]\n *                                           // [7,1]\n *                                           // [8,1]\n *                                           // ...\n */\n\nconst EMPTY = {};\n\nconst combine = (...sources) => (start, sink) => {\n  if (start !== 0) return;\n  const n = sources.length;\n  if (n === 0) {\n    sink(0, () => {});\n    sink(1, []);\n    sink(2);\n    return;\n  }\n  let Ns = n; // start counter\n  let Nd = n; // data counter\n  let Ne = n; // end counter\n  const vals = new Array(n);\n  const sourceTalkbacks = new Array(n);\n  const talkback = (t, d) => {\n    if (t === 0) return;\n    for (let i = 0; i < n; i++) sourceTalkbacks[i](t, d);\n  };\n  sources.forEach((source, i) => {\n    vals[i] = EMPTY;\n    source(0, (t, d) => {\n      if (t === 0) {\n        sourceTalkbacks[i] = d;\n        if (--Ns === 0) sink(0, talkback);\n      } else if (t === 1) {\n        const _Nd = !Nd ? 0 : vals[i] === EMPTY ? --Nd : Nd;\n        vals[i] = d;\n        if (_Nd === 0) {\n          const arr = new Array(n);\n          for (let j = 0; j < n; ++j) arr[j] = vals[j];\n          sink(1, arr);\n        }\n      } else if (t === 2) {\n        if (--Ne === 0) sink(2);\n      } else {\n        sink(t, d);\n      }\n    });\n  });\n};\n\nmodule.exports = combine;\n","/**\n * callbag-concat\n * --------------\n *\n * Callbag factory that concatenates the data from multiple (2 or more)\n * callbag sources. It starts each source at a time: waits for the previous\n * source to end before starting the next source. Works with both pullable\n * and listenable sources.\n *\n * `npm install callbag-concat`\n *\n * Example:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const iterate = require('callbag-iterate');\n *     const concat = require('callbag-concat');\n *\n *     const source = concat(fromIter([10,20,30]), fromIter(['a','b']));\n *\n *     iterate(x => console.log(x))(source); // 10\n *                                           // 20\n *                                           // 30\n *                                           // a\n *                                           // b\n */\n\nconst UNIQUE = {};\n\nconst concat = (...sources) => (start, sink) => {\n  if (start !== 0) return;\n  const n = sources.length;\n  if (n === 0) {\n    sink(0, () => {});\n    sink(2);\n    return;\n  }\n  let i = 0;\n  let sourceTalkback;\n  let lastPull = UNIQUE;\n  const talkback = (t, d) => {\n    if (t === 1) lastPull = d;\n    sourceTalkback(t, d);\n  };\n  (function next() {\n    if (i === n) {\n      sink(2);\n      return;\n    }\n    sources[i](0, (t, d) => {\n      if (t === 0) {\n        sourceTalkback = d;\n        if (i === 0) sink(0, talkback);\n        else if (lastPull !== UNIQUE) sourceTalkback(1, lastPull);\n      } else if (t === 2 && d) {\n        sink(2, d);\n      } else if (t === 2) {\n        i++;\n        next();\n      } else {\n        sink(t, d);\n      }\n    });\n  })();\n};\n\nexport default concat;\n","/**\n * callbag-filter\n * --------------\n *\n * Callbag operator that conditionally lets data pass through. Works on either\n * pullable or listenable sources.\n *\n * `npm install callbag-filter`\n *\n * Example:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const iterate = require('callbag-iterate');\n *     const filter = require('callbag-filter');\n *\n *     const source = filter(x => x % 2)(fromIter([1,2,3,4,5]));\n *\n *     iterate(x => console.log(x))(source); // 1\n *                                           // 3\n *                                           // 5\n */\n\nconst filter = condition => source => (start, sink) => {\n  if (start !== 0) return;\n  let talkback;\n  source(0, (t, d) => {\n    if (t === 0) {\n      talkback = d;\n      sink(t, d);\n    } else if (t === 1) {\n      if (condition(d)) sink(t, d);\n      else talkback(1);\n    }\n    else sink(t, d);\n  });\n};\n\nmodule.exports = filter;\n","const flatten = source => (start, sink) => {\n  if (start !== 0) return;\n  let outerTalkback;\n  let innerTalkback;\n  function talkback(t, d) {\n    if (t === 1) (innerTalkback || outerTalkback)(1, d);\n    if (t === 2) {\n      innerTalkback && innerTalkback(2);\n      outerTalkback && outerTalkback(2);\n    }\n  }\n  source(0, (T, D) => {\n    if (T === 0) {\n      outerTalkback = D;\n      sink(0, talkback);\n    } else if (T === 1) {\n      const innerSource = D;\n      innerTalkback && innerTalkback(2);\n      innerSource(0, (t, d) => {\n        if (t === 0) {\n          innerTalkback = d;\n          innerTalkback(1);\n        } else if (t === 1) sink(1, d);\n        else if (t === 2 && d) {\n          outerTalkback && outerTalkback(2);\n          sink(2, d);\n        } else if (t === 2) {\n          if (!outerTalkback) sink(2);\n          else {\n            innerTalkback = void 0;\n            outerTalkback(1);\n          }\n        }\n      });\n    } else if (T === 2 && D) {\n      innerTalkback && innerTalkback(2);\n      sink(2, D);\n    } else if (T === 2) {\n      if (!innerTalkback) sink(2);\n      else outerTalkback = void 0;\n    }\n  });\n};\n\nexport default flatten;\n","/**\n * callbag-for-each\n * ----------------\n *\n * Callbag sink that consume both pullable and listenable sources. When called\n * on a pullable source, it will iterate through its data. When called on a\n * listenable source, it will observe its data.\n *\n * `npm install callbag-for-each`\n *\n * Examples\n * --------\n *\n * Consume a pullable source:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const forEach = require('callbag-for-each');\n *\n *     const source = fromIter([10,20,30,40])\n *\n *     forEach(x => console.log(x))(source); // 10\n *                                           // 20\n *                                           // 30\n *                                           // 40\n *\n * Consume a listenable source:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *\n *     const source = interval(1000);\n *\n *     forEach(x => console.log(x))(source); // 0\n *                                           // 1\n *                                           // 2\n *                                           // 3\n *                                           // ...\n */\n\nconst forEach = operation => source => {\n  let talkback;\n  source(0, (t, d) => {\n    if (t === 0) talkback = d;\n    if (t === 1) operation(d);\n    if (t === 1 || t === 0) talkback(1);\n  });\n};\n\nmodule.exports = forEach;\n","const fromEvent = (node, name, options) => (start, sink) => {\n  if (start !== 0) return;\n  let disposed = false;\n  const handler = ev => {\n    sink(1, ev)\n  };\n\n  sink(0, t => {\n    if (t !== 2) {\n      return;\n    }\n    disposed = true;\n    if (node.removeEventListener) node.removeEventListener(name, handler, options);\n    else if (node.removeListener) node.removeListener(name, handler);\n    else throw new Error('cannot remove listener from node. No method found.');\n  });\n\n  if (disposed) {\n    return;\n  }\n\n  if (node.addEventListener) node.addEventListener(name, handler, options);\n  else if (node.addListener) node.addListener(name, handler);\n  else throw new Error('cannot add listener to node. No method found.');\n};\n\nexport default fromEvent;\n","const fromIter = iter => (start, sink) => {\n  if (start !== 0) return;\n  const iterator =\n    typeof Symbol !== 'undefined' && iter[Symbol.iterator]\n      ? iter[Symbol.iterator]()\n      : iter;\n  let inloop = false;\n  let got1 = false;\n  let completed = false;\n  let res;\n  function loop() {\n    inloop = true;\n    while (got1 && !completed) {\n      got1 = false;\n      res = iterator.next();\n      if (res.done) {\n        sink(2);\n        break;\n      }\n      else sink(1, res.value);\n    }\n    inloop = false;\n  }\n  sink(0, t => {\n    if (completed) return\n\n    if (t === 1) {\n      got1 = true;\n      if (!inloop && !(res && res.done)) loop();\n    } else if (t === 2) {\n      completed = true;\n    }\n  });\n};\n\nmodule.exports = fromIter;\n","/**\n * callbag-from-obs\n * --------------\n *\n * Convert an observable (or subscribable) to a callbag listenable source.\n *\n * `npm install callbag-from-obs`\n *\n * Example:\n *\n * Convert an RxJS Observable:\n *\n *     const Rx = require('rxjs');\n *     const fromObs = require('callbag-from-obs');\n *     const observe = require('callbag-observe');\n *\n *     const source = fromObs(Rx.Observable.interval(1000).take(4));\n *\n *     observe(x => console.log(x)(source); // 0\n *                                          // 1\n *                                          // 2\n *                                          // 3\n *\n * Convert anything that has the `.subscribe` method:\n *\n *     const fromObs = require('callbag-from-obs');\n *     const observe = require('callbag-observe');\n *\n *     const subscribable = {\n *       subscribe: (observer) => {\n *         let i = 0;\n *         setInterval(() => observer.next(i++), 1000);\n *       }\n *     };\n *\n *     const source = fromObs(subscribable);\n *\n *     observe(x => console.log(x))(source); // 0\n *                                           // 1\n *                                           // 2\n *                                           // 3\n *                                           // ...\n */\n\nconst $$observable = require('symbol-observable').default;\n\nconst fromObs = observable => (start, sink) => {\n  if (start !== 0) return;\n  let dispose;\n  sink(0, t => {\n    if (t === 2 && dispose) {\n      if (dispose.unsubscribe) dispose.unsubscribe();\n      else dispose();\n    }\n  });\n  observable = observable[$$observable] ? observable[$$observable]() : observable;\n  dispose = observable.subscribe({\n    next: x => sink(1, x),\n    error: e => sink(2, e),\n    complete: () => sink(2)\n  });\n};\n\nmodule.exports = fromObs;\n","const fromPromise = promise => (start, sink) => {\n  if (start !== 0) return;\n  let ended = false;\n  const onfulfilled = val => {\n    if (ended) return;\n    sink(1, val);\n    if (ended) return;\n    sink(2);\n  };\n  const onrejected = (err = new Error()) => {\n    if (ended) return;\n    sink(2, err);\n  };\n  promise.then(onfulfilled, onrejected);\n  sink(0, t => {\n    if (t === 2) ended = true;\n  });\n};\n\nexport default fromPromise;\n","const interval = period => (start, sink) => {\n  if (start !== 0) return;\n  let i = 0;\n  const id = setInterval(() => {\n    sink(1, i++);\n  }, period);\n  sink(0, t => {\n    if (t === 2) clearInterval(id);\n  });\n};\n\nexport default interval;\n","/**\n * callbag-map\n * -----------\n *\n * Callbag operator that applies a transformation on data passing through it.\n * Works on either pullable or listenable sources.\n *\n * `npm install callbag-map`\n *\n * Example:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const iterate = require('callbag-iterate');\n *     const map = require('callbag-map');\n *\n *     const source = map(x => x * 0.1)(fromIter([10,20,30,40]));\n *\n *     iterate(x => console.log(x))(source); // 1\n *                                           // 2\n *                                           // 3\n *                                           // 4\n */\n\nconst map = f => source => (start, sink) => {\n  if (start !== 0) return;\n  source(0, (t, d) => {\n    sink(t, t === 1 ? f(d) : d)\n  });\n};\n\nmodule.exports = map;\n","/**\n * callbag-merge\n * -------------\n *\n * Callbag factory that merges data from multiple callbag sources. Works well\n * with listenable sources, and while it may work for some pullable sources,\n * it is only designed for listenable sources.\n *\n * `npm install callbag-merge`\n *\n * Example:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const merge = require('callbag-merge');\n *\n *     const source = merge(interval(100), interval(350));\n *\n *     forEach(x => console.log(x))(source); // 0\n *                                           // 1\n *                                           // 2\n *                                           // 0\n *                                           // 3\n *                                           // 4\n *                                           // 5\n *                                           // ...\n */\n\nfunction merge(...sources) {\n  return (start, sink) => {\n    if (start !== 0) return;\n    const n = sources.length;\n    const sourceTalkbacks = new Array(n);\n    let startCount = 0;\n    let endCount = 0;\n    let ended = false;\n    const talkback = (t, d) => {\n      if (t === 2) ended = true;\n      for (let i = 0; i < n; i++) sourceTalkbacks[i] && sourceTalkbacks[i](t, d);\n    };\n    for (let i = 0; i < n; i++) {\n      if (ended) return;\n      sources[i](0, (t, d) => {\n        if (t === 0) {\n          sourceTalkbacks[i] = d;\n          if (++startCount === 1) sink(0, talkback);\n        } else if (t === 2 && d) {\n          ended = true;\n          for (let j = 0; j < n; j++) {\n            if (j !== i) sourceTalkbacks[j] && sourceTalkbacks[j](2);\n          }\n          sink(2, d);\n        } else if (t === 2) {\n          sourceTalkbacks[i] = void 0;\n          if (++endCount === n) sink(2);\n        } else sink(t, d);\n      });\n    }\n  };\n}\n\nexport default merge;\n","/**\n * callbag-pipe\n * ------------\n *\n * Utility function for plugging callbags together in chain. This utility\n * actually doesn't rely on Callbag specifics, and is really similar to\n * Ramda's `pipe` or lodash's `flow`.\n * \n * Implementation of `callbag-pipe` using `R.pipe` could look like this:\n *\n * const pipe = (source, ...cbs) => R.pipe(...cbs)(source)\n * \n * This exists to play nicely with the ecosystem,\n * and to facilitate the import of the function.\n *\n * `npm install callbag-pipe`\n *\n * Example:\n *\n * Create a source with `pipe`, then pass it to a `forEach`:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     const source = pipe(\n *       combine(interval(100), interval(350)),\n *       map(([x, y]) => `X${x},Y${y}`),\n *       take(10)\n *     );\n *\n *     forEach(x => console.log(x))(source); // X2,Y0\n *                                           // X3,Y0\n *                                           // X4,Y0\n *                                           // X5,Y0\n *                                           // X6,Y0\n *                                           // X6,Y1\n *                                           // X7,Y1\n *                                           // X8,Y1\n *                                           // X9,Y1\n *                                           // X9,Y2\n *\n *\n * Or use `pipe` to go all the way from source to sink:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       map(([x, y]) => `X${x},Y${y}`),\n *       take(10),\n *       forEach(x => console.log(x))\n *     );\n *     // X2,Y0\n *     // X3,Y0\n *     // X4,Y0\n *     // X5,Y0\n *     // X6,Y0\n *     // X6,Y1\n *     // X7,Y1\n *     // X8,Y1\n *     // X9,Y1\n *     // X9,Y2\n *\n *\n * Nesting\n * -------\n *\n * To use pipe inside another pipe, you need to give the inner pipe an\n * argument, e.g. `s => pipe(s, ...`:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       s => pipe(s,\n *         map(([x, y]) => `X${x},Y${y}`),\n *         take(10)\n *       ),\n *       forEach(x => console.log(x))\n *     );\n *\n *\n * This means you can use pipe to create a new operator:\n *\n *     const mapThenTake = (f, amount) =>\n *       s => pipe(s, map(f), take(amount));\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       mapThenTake(([x, y]) => `X${x},Y${y}`, 10),\n *       forEach(x => console.log(x))\n *     );\n *\n */\n\nfunction pipe(...cbs) {\n  let res = cbs[0];\n  for (let i = 1, n = cbs.length; i < n; i++) res = cbs[i](res);\n  return res;\n}\n\nmodule.exports = pipe;\n","/**\n * callbag-scan\n * ------------\n *\n * Callbag operator that combines consecutive values from the same source.\n * It's essentially like array `.reduce`, but delivers a new accumulated value\n * for each value from the callbag source. Works on either pullable or\n * listenable sources.\n *\n * `npm install callbag-scan`\n *\n * Example:\n *\n *     const fromIter = require('callbag-from-iter');\n *     const iterate = require('callbag-iterate');\n *     const scan = require('callbag-scan');\n *\n *     const iterSource = fromIter([1,2,3,4,5]);\n *     const scanned = scan((prev, x) => prev + x, 0)(iterSource);\n *\n *     scanned(0, iterate(x => console.log(x))); // 1\n *                                               // 3\n *                                               // 6\n *                                               // 10\n *                                               // 15\n */\n\nfunction scan(reducer, seed) {\n  let hasAcc = arguments.length === 2;\n  return source => (start, sink) => {\n    if (start !== 0) return;\n    let acc = seed;\n    source(0, (t, d) => {\n      if (t === 1) {\n        acc = hasAcc ? reducer(acc, d) : ((hasAcc = true), d);\n        sink(1, acc);\n      } else sink(t, d);\n    });\n  };\n}\n\nmodule.exports = scan;\n","const share = source => {\n  let sinks = [];\n  let sourceTalkback;\n\n  return function shared(start, sink) {\n    if (start !== 0) return;\n    sinks.push(sink);\n\n    const talkback = (t, d) => {\n      if (t === 2) {\n        const i = sinks.indexOf(sink);\n        if (i > -1) sinks.splice(i, 1);\n        if (!sinks.length) sourceTalkback(2);\n      } else {\n        sourceTalkback(t, d);\n      }\n    };\n\n    if (sinks.length === 1) {\n      source(0, (t, d) => {\n        if (t === 0) {\n          sourceTalkback = d;\n          sink(0, talkback);\n        } else for (let s of sinks.slice(0)) s(t, d);\n        if (t === 2) sinks = [];\n      });\n      return\n    }\n\n    sink(0, talkback);\n  }\n};\n\nexport default share;\n","const skip = max => source => (start, sink) => {\n  if (start !== 0) return;\n  let skipped = 0;\n  let talkback;\n  source(0, (t, d) => {\n    if (t === 0) {\n      talkback = d;\n      sink(t, d);\n    } else if (t === 1) {\n      if (skipped < max) {\n        skipped++;\n        talkback(1);\n      } else sink(t, d);\n    } else {\n      sink(t, d);\n    }\n  });\n};\n\nmodule.exports = skip;\n","const take = max => source => (start, sink) => {\n  if (start !== 0) return;\n  let taken = 0;\n  let sourceTalkback;\n  let end;\n  function talkback(t, d) {\n    if (t === 2) {\n      end = true;\n      sourceTalkback(t, d);\n    } else if (taken < max) sourceTalkback(t, d);\n  }\n  source(0, (t, d) => {\n    if (t === 0) {\n      sourceTalkback = d;\n      sink(0, talkback);\n    } else if (t === 1) {\n      if (taken < max) {\n        taken++;\n        sink(t, d);\n        if (taken === max && !end) {\n          end = true\n          sourceTalkback(2);\n          sink(2);\n        }\n      }\n    } else {\n      sink(t, d);\n    }\n  });\n};\n\nmodule.exports = take;\n","const toWorker = fileOrWorker =>\n  typeof fileOrWorker === 'string' \n    ? new Worker(fileOrWorker)\n    : fileOrWorker\n\nconst workerSource = fileOrWorker => {\n  const w = toWorker(fileOrWorker)\n  return (start, sink) => {\n    if (start !== 0) return\n    const onMsg = ev => {\n      const {type, data} = JSON.parse(ev.data)\n      if (type !== 0) sink(type, data)\n    }\n    if (w.addEventListener) w.addEventListener('message', onMsg)\n    else w.onmessage = onMsg\n    sink(0, (t, d) => {\n      w.postMessage(JSON.stringify({type: t, data: d}))\n      if (t === 2) (w.close || w.terminate).call(w)\n    })\n  }\n}\n\nconst workerSink = fileOrWorker => source => {\n  const w = toWorker(fileOrWorker)\n  let talkback;\n  const onMsg = ev => {\n    const {type, data} = JSON.parse(ev.data)\n    talkback(type, data)\n  }\n  source(0, (t, d) => {\n    if (t === 0) {\n      talkback = d\n      if (w.addEventListener) w.addEventListener('message', onMsg)\n      else w.onmessage = onMsg\n      w.postMessage(JSON.stringify({type: 0}))\n    }\n    if (t === 1) w.postMessage(JSON.stringify({type: t, data: d}))\n    if (t === 2) {\n      w.postMessage(JSON.stringify({type: t, data: d}))\n      const close = w.close || w.terminate\n      close.call(w);\n    }\n  })\n}\n\nmodule.exports = {workerSource, workerSink};\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".bundle.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t792: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","// main.js\nimport { pipe, take, map, forEach } from 'callbag-basics'\nimport { workerSource } from 'callbag-worker'\n\npipe(\n    workerSource(new Worker(new URL('./worker.js', import.meta.url))), // or workerSource('worker.js')\n    take(5),\n    map(x => x / 2),\n    forEach(x => console.log(x))\n)\n// 0.5\n// 1.5\n// 2.5\n// 3.5\n// 4.5"],"names":["module","exports","forEach","fromObs","fromIter","fromEvent","fromPromise","interval","map","scan","flatten","take","skip","filter","merge","concat","combine","share","pipe","EMPTY","sources","start","sink","n","length","Ns","Nd","Ne","vals","Array","sourceTalkbacks","talkback","t","d","i","source","_Nd","arr","j","UNIQUE","sourceTalkback","lastPull","next","condition","outerTalkback","innerTalkback","T","D","innerSource","operation","node","name","options","disposed","handler","ev","removeEventListener","removeListener","Error","addEventListener","addListener","iter","iterator","Symbol","res","inloop","got1","completed","done","value","loop","$$observable","observable","dispose","unsubscribe","subscribe","x","error","e","complete","promise","ended","then","val","err","period","id","setInterval","clearInterval","f","startCount","endCount","cbs","reducer","seed","hasAcc","arguments","acc","sinks","push","indexOf","splice","s","slice","max","skipped","end","taken","toWorker","fileOrWorker","Worker","workerSource","w","onMsg","type","data","JSON","parse","onmessage","postMessage","stringify","close","terminate","call","workerSink","root","result","self","window","g","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","loaded","__webpack_modules__","m","getter","__esModule","a","definition","key","o","Object","defineProperty","enumerable","get","u","chunkId","globalThis","this","Function","hmd","create","children","set","obj","prop","prototype","hasOwnProperty","r","toStringTag","scriptUrl","importScripts","location","document","currentScript","tagName","toUpperCase","src","scripts","getElementsByTagName","test","replace","p","b","baseURI","href","URL","console","log"],"sourceRoot":""}