{"version":3,"file":"408.bundle.js","mappings":"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","sources":["webpack://web-sequencer-webpack/./node_modules/callbag-pausable-interval/index.js","webpack://web-sequencer-webpack/./node_modules/callbag-pipe/readme.js","webpack://web-sequencer-webpack/./node_modules/callbag-worker/index.js","webpack://web-sequencer-webpack/webpack/bootstrap","webpack://web-sequencer-webpack/webpack/runtime/compat get default export","webpack://web-sequencer-webpack/webpack/runtime/define property getters","webpack://web-sequencer-webpack/webpack/runtime/hasOwnProperty shorthand","webpack://web-sequencer-webpack/./src/worker.js"],"sourcesContent":["const pausableInterval = period => (start, sink) => {\n  if (start !== 0) return;\n  let i = 0, id = null;\n  const pause = () => {\n    clearInterval(id);\n    id = null;\n  };\n  const resume = () => {\n    id = setInterval(() => { sink(1, i++); }, period);\n  };\n  sink(0, t => {\n    if (t === 1) {\n      if (id) pause();\n      else resume();\n    }\n    if (t === 2) pause();\n  });\n  resume();\n};\n\nmodule.exports = pausableInterval;\n","/**\n * callbag-pipe\n * ------------\n *\n * Utility function for plugging callbags together in chain. This utility\n * actually doesn't rely on Callbag specifics, and is really similar to\n * Ramda's `pipe` or lodash's `flow`.\n * \n * Implementation of `callbag-pipe` using `R.pipe` could look like this:\n *\n * const pipe = (source, ...cbs) => R.pipe(...cbs)(source)\n * \n * This exists to play nicely with the ecosystem,\n * and to facilitate the import of the function.\n *\n * `npm install callbag-pipe`\n *\n * Example:\n *\n * Create a source with `pipe`, then pass it to a `forEach`:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     const source = pipe(\n *       combine(interval(100), interval(350)),\n *       map(([x, y]) => `X${x},Y${y}`),\n *       take(10)\n *     );\n *\n *     forEach(x => console.log(x))(source); // X2,Y0\n *                                           // X3,Y0\n *                                           // X4,Y0\n *                                           // X5,Y0\n *                                           // X6,Y0\n *                                           // X6,Y1\n *                                           // X7,Y1\n *                                           // X8,Y1\n *                                           // X9,Y1\n *                                           // X9,Y2\n *\n *\n * Or use `pipe` to go all the way from source to sink:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       map(([x, y]) => `X${x},Y${y}`),\n *       take(10),\n *       forEach(x => console.log(x))\n *     );\n *     // X2,Y0\n *     // X3,Y0\n *     // X4,Y0\n *     // X5,Y0\n *     // X6,Y0\n *     // X6,Y1\n *     // X7,Y1\n *     // X8,Y1\n *     // X9,Y1\n *     // X9,Y2\n *\n *\n * Nesting\n * -------\n *\n * To use pipe inside another pipe, you need to give the inner pipe an\n * argument, e.g. `s => pipe(s, ...`:\n *\n *     const interval = require('callbag-interval');\n *     const forEach = require('callbag-for-each');\n *     const combine = require('callbag-combine');\n *     const pipe = require('callbag-pipe');\n *     const take = require('callbag-take');\n *     const map = require('callbag-map');\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       s => pipe(s,\n *         map(([x, y]) => `X${x},Y${y}`),\n *         take(10)\n *       ),\n *       forEach(x => console.log(x))\n *     );\n *\n *\n * This means you can use pipe to create a new operator:\n *\n *     const mapThenTake = (f, amount) =>\n *       s => pipe(s, map(f), take(amount));\n *\n *     pipe(\n *       combine(interval(100), interval(350)),\n *       mapThenTake(([x, y]) => `X${x},Y${y}`, 10),\n *       forEach(x => console.log(x))\n *     );\n *\n */\n\nfunction pipe(...cbs) {\n  let res = cbs[0];\n  for (let i = 1, n = cbs.length; i < n; i++) res = cbs[i](res);\n  return res;\n}\n\nmodule.exports = pipe;\n","const toWorker = fileOrWorker =>\n  typeof fileOrWorker === 'string' \n    ? new Worker(fileOrWorker)\n    : fileOrWorker\n\nconst workerSource = fileOrWorker => {\n  const w = toWorker(fileOrWorker)\n  return (start, sink) => {\n    if (start !== 0) return\n    const onMsg = ev => {\n      const {type, data} = JSON.parse(ev.data)\n      if (type !== 0) sink(type, data)\n    }\n    if (w.addEventListener) w.addEventListener('message', onMsg)\n    else w.onmessage = onMsg\n    sink(0, (t, d) => {\n      w.postMessage(JSON.stringify({type: t, data: d}))\n      if (t === 2) (w.close || w.terminate).call(w)\n    })\n  }\n}\n\nconst workerSink = fileOrWorker => source => {\n  const w = toWorker(fileOrWorker)\n  let talkback;\n  const onMsg = ev => {\n    const {type, data} = JSON.parse(ev.data)\n    talkback(type, data)\n  }\n  source(0, (t, d) => {\n    if (t === 0) {\n      talkback = d\n      if (w.addEventListener) w.addEventListener('message', onMsg)\n      else w.onmessage = onMsg\n      w.postMessage(JSON.stringify({type: 0}))\n    }\n    if (t === 1) w.postMessage(JSON.stringify({type: t, data: d}))\n    if (t === 2) {\n      w.postMessage(JSON.stringify({type: t, data: d}))\n      const close = w.close || w.terminate\n      close.call(w);\n    }\n  })\n}\n\nmodule.exports = {workerSource, workerSink};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// worker.js\r\nimport pipe from 'callbag-pipe'\r\nimport pausableInterval from 'callbag-pausable-interval'\r\nimport { workerSink } from 'callbag-worker'\r\n\r\npipe(\r\n    pausableInterval(1000),\r\n    workerSink(self)\r\n)"],"names":["module","exports","period","start","sink","i","id","pause","clearInterval","resume","setInterval","t","cbs","res","n","length","toWorker","fileOrWorker","Worker","workerSource","w","onMsg","ev","type","data","JSON","parse","addEventListener","onmessage","d","postMessage","stringify","close","terminate","call","workerSink","source","talkback","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","getter","__esModule","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","self"],"sourceRoot":""}